// Loads assets from SI files via HTTP Range requests
// using the offset manifest generated by scripts/generate-manifest.js

let manifest = null;

async function loadManifest() {
  if (!manifest) {
    const resp = await fetch('/asset-ranges.json');
    manifest = await resp.json();
  }
  return manifest;
}

async function fetchRange(siFile, offset, size) {
  const resp = await fetch(`/LEGO/${siFile}`, {
    headers: { Range: `bytes=${offset}-${offset + size - 1}` },
  });
  return resp.arrayBuffer();
}

async function fetchEntry(entry) {
  if (Array.isArray(entry)) {
    // Contiguous: [siFile, offset, size]
    return fetchRange(entry[0], entry[1], entry[2]);
  }
  // Split file: { si, ranges: [[offset, size], ...] }
  const buffers = await Promise.all(
    entry.ranges.map(([offset, size]) => fetchRange(entry.si, offset, size)),
  );
  const total = buffers.reduce((s, b) => s + b.byteLength, 0);
  const result = new Uint8Array(total);
  let pos = 0;
  for (const buf of buffers) {
    result.set(new Uint8Array(buf), pos);
    pos += buf.byteLength;
  }
  return result.buffer;
}

export async function fetchAnimation(name) {
  const m = await loadManifest();
  const entry = m.animations[name];
  if (!entry) return null;
  return fetchEntry(entry);
}

export async function fetchTexture(name) {
  const m = await loadManifest();
  const entry = m.textures[name];
  if (!entry) return null;
  return fetchEntry(entry);
}

export async function fetchBitmap(name) {
  const m = await loadManifest();
  const entry = m.bitmaps[name];
  if (!entry) return null;
  return fetchEntry(entry);
}

async function fetchSound(name) {
  const m = await loadManifest();
  const entry = m.sounds[name];
  if (!entry) return null;
  return fetchEntry(entry);
}

/**
 * Build a WAV file from raw MxCh sound data.
 * Layout: bytes 0-15 = PCMWAVEFORMAT, 16-19 = m_dataSize, 20-23 = m_flags, 24+ = PCM data.
 * Uses actual available size since sector interleaving may clip the last chunk.
 */
function buildWav(buffer) {
  const dataSize = buffer.byteLength - 24;
  const wavSize = 44 + dataSize;
  const wav = new ArrayBuffer(wavSize);
  const view = new DataView(wav);
  const bytes = new Uint8Array(wav);

  // RIFF header
  bytes.set([0x52, 0x49, 0x46, 0x46]); // "RIFF"
  view.setUint32(4, wavSize - 8, true);
  bytes.set([0x57, 0x41, 0x56, 0x45], 8); // "WAVE"

  // fmt chunk â€” copy PCMWAVEFORMAT (16 bytes) directly from source header
  bytes.set([0x66, 0x6D, 0x74, 0x20], 12); // "fmt "
  view.setUint32(16, 16, true);
  bytes.set(new Uint8Array(buffer, 0, 16), 20);

  // data chunk
  bytes.set([0x64, 0x61, 0x74, 0x61], 36); // "data"
  view.setUint32(40, dataSize, true);
  bytes.set(new Uint8Array(buffer, 24, dataSize), 44);

  return wav;
}

export async function fetchSoundAsWav(name) {
  const buffer = await fetchSound(name);
  if (!buffer) return null;
  return buildWav(buffer);
}

/**
 * Decode a raw Windows DIB (no BM file header) into RGBA ImageData.
 * Supports 8-bit indexed color only.
 */
function decodeDib(buffer) {
  const view = new DataView(buffer);
  const width = view.getInt32(4, true);
  const height = view.getInt32(8, true);
  const bpp = view.getUint16(14, true);
  if (bpp !== 8) return null;

  // Palette: 256 BGRA entries starting at offset 40
  const palette = new Uint8Array(buffer, 40, 1024);

  // Pixel data starts after header + palette
  const pixelOffset = 40 + 1024;
  const rowStride = (width + 3) & ~3; // rows padded to 4-byte boundary
  const absHeight = Math.abs(height);
  const bottomUp = height > 0;

  const imageData = new ImageData(width, absHeight);
  const pixels = new Uint8Array(buffer, pixelOffset);

  for (let y = 0; y < absHeight; y++) {
    const srcRow = bottomUp ? (absHeight - 1 - y) : y;
    for (let x = 0; x < width; x++) {
      const idx = pixels[srcRow * rowStride + x] * 4;
      const dst = (y * width + x) * 4;
      imageData.data[dst] = palette[idx + 2];     // R (from BGR)
      imageData.data[dst + 1] = palette[idx + 1]; // G
      imageData.data[dst + 2] = palette[idx];     // B
      imageData.data[dst + 3] = 255;
    }
  }

  return imageData;
}

/**
 * Fetch a bitmap from an SI file and return a blob URL for use in <img> tags.
 */
export async function fetchBitmapAsURL(name) {
  const buffer = await fetchBitmap(name);
  if (!buffer) return null;

  const imageData = decodeDib(buffer);
  if (!imageData) return null;

  const canvas = new OffscreenCanvas(imageData.width, imageData.height);
  const ctx = canvas.getContext('2d');
  ctx.putImageData(imageData, 0, 0);

  const blob = await canvas.convertToBlob({ type: 'image/png' });
  return URL.createObjectURL(blob);
}
